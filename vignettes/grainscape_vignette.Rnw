% -*- mode: noweb; noweb-default-code-mode: R-mode; -*-
%\VignetteIndexEntry{grainscape supplementary documentation with tutorials}
\documentclass[11pt]{article}


\SweaveOpts{echo=FALSE}
\usepackage{a4wide}
\usepackage{parskip}
\usepackage{natbib}
\usepackage{amsmath}
\usepackage{float}
\usepackage{xcolor,soul,lipsum}
\usepackage{lineno}
\usepackage[auth-lg, affil-it]{authblk}
\usepackage[bookmarks=false, colorlinks=true, citecolor=black, linkcolor=red, urlcolor=red]{hyperref}



\title{The \textsc{grainscape} package for R:\\Tutorials using simulated landscapes\\(Prepared: June 21st, 2013)}
\author[1,2]{P. Galpern}
\author[3]{B. Rayfield}
\affil[1]{Natural Resources Institute, University of Manitoba, Winnipeg, Canada}
\affil[2]{email: pgalpern@gmail.com (for support, bug reports, etc.)}
\affil[3]{Department of Biology, McGill University}
\date{}



\bibliographystyle{Plainnat}
\bibpunct{(}{)}{;}{a}{,}{,}



\newcommand{\hr}[2]{\href{#1}{\setulcolor{red}\ul{#2}}}

\begin{document}

\maketitle

\tableofcontents
\newpage

<<echo=FALSE,print=FALSE>>=
library(grainscape)
options(width=75)
@

\DefineVerbatimEnvironment{Sinput}{Verbatim}{fontsize=\small,fontshape=n}
\DefineVerbatimEnvironment{Soutput}{Verbatim}{fontsize=\small,fontshape=n}
\DefineVerbatimEnvironment{Scode}{Verbatim}{fontsize=\small,fontshape=n}

\section{Introduction}

This document is a supplement to the \textsc{grainscape} package, and is  included as an R vignette. \textsc{grainscape} can be downloaded at \hr{http://grainscape.r-forge.r-project.org}{http://grainscape.r-forge.r-project.org}.  Here, we illustrate the use of the package in a tutorial format.

Are animals free to move across the landscape?  What, if anything, may limit or encourage their movement and dispersal.  These are the questions of landscape connectivity research, and natural resource managers and practitioners of conservation are increasingly asking them in the course of their work.  What are the effects of habitat fragmentation, and can organisms find new habitat when they need to?  Can corridors help?  Is it possible to stop the spread of  pests and pathogens by managing the connectivity of their hosts?

The \textsc{grainscape} package was developed for landscape connectivity analyses.  The approach comes from the patch-based landscape graphs tradition \citep{urban_keitt_2001, fall_etal_2007, galpern_etal_2011} where a mathematical graph or network is used to represent the relationships among habitat patches.  \textsc{grainscape} provides two types of landscape connectivity models.  The first, a minimum planar graph \citep{fall_etal_2007} is an efficient approximation of the potential for connectivity among a set of habitat patches.

The second model type is the grain of connectivity, which is based on the minimum planar graph, but extends in a way that may be useful for highly mobile terrestrial animals, such as ungulates and carnivores.  For these organisms the patch may be not be a discrete and definable feature or landcover type, but is rather defined probabilistically (e.g. as the probability of resource selection).  By modelling the relationships among a polygons in a Voronoi tessellation of the landscape rather than discrete patches, grains of connectivity offers improvements in the ability to model highly-mobile organisms \citep{galpern_etal_2012}.  Importantly it provides continuous coverage of the entire landscape surface, in a way that a typical patch-based graph does not, and the ability to measure landscape connectivity at multiple scales.  The scalability, in particular, offers flexibility to accommodate uncertainty in how species may perceive landscape features.

\textsc{grainscape} provides functions to extract the minimum planar graph and create two types of grains of connectivity:  patch-based and lattic forms.  The minimum planar graph, an essential step in all cases is extracted using a Windows-based binary SELES \citep{fall_fall_2001} that is distributed with the software.  Consequently, the package works only on a Windows platform (or running R on a Windows virtual machine).

\section{Tutorials}

There are five tutorials.  The first demonstrates how to extract a minimum planar graph and illustrates how it may be used to ask questions about landscape connectivity.  The second demonstrates patch-based grains of connectivity modelling where animals are known to have some affinity to a resource patch, and the third uses lattice grains of connectivity modelling, an approach that is more appropriate where a patch concept does not clearly apply.  A fourth tutorial demonstrates how to produce more advanced visualizations of grains of connectivity and the corridors connecting locations.  A final tutorial describes how to produce a minimum planar graph for very large landscapes using a purpose-built function to stitch sub-regions of the landscape together (contributed by Bronwyn Rayfield)

In each case we draw on artificial landscape data that is provided with the package.  All analyses presented here can be run with the basic \textsc{grainscape} installation.


\begin{description}


\item[Tutorial 1] The minimum planar graph
\addcontentsline{toc}{subsection}{The minimum planar graph}

The minimum planar graph (hereafter MPG) is a spatial representation of a graph or a network that provides an efficient approximation of all possible pairwise connections between graph nodes \citep{fall_etal_2007}.  In graph-based landscape connectivity analyses, graph nodes have typically been patches of habitat that are demonstrably important for the species in question \citep{fall_etal_2007}.

An MPG has links (i.e. models the possibility for organism movement and dispersal) between spatially adjacent habitat patches.  In some cases spatially adjacent patches may not be linked, if the shortest connection between them can be made through a third patch.  In practice, this property means that the MPG can be used to make a simple and easily visualized picture of how a set of habitat patches is connected.  The alternative, the complete graph, can quickly become challenging to interpret because these may contain a dense set of graph links making the pattern difficult to discern.  A second advantage of the MPG is the much reduced set of graph links;  this can be valuable where computational efficiency is important, and essential where the number of habitat patches being modelled numbers in the thousands.

However, there are some types of connectivity analyses where the MPG approximation of the complete graph is not appropriate.  For example, assessing community structure within a landscape patch network (i.e. finding sets of patches that are densely connected) is not possible as redundant connections have been removed intentionally.  Equally, the MPG is a poor choice for prioritizing the influence of a patch for connectivity, the objective in a number of landscape graph studies e.g. \citep{pascualhortal_saura_2006}. Please see \citep{galpern_etal_2011} for further discussion of these limitations and of the MPG.

\begin{description}
\item[Step 1] Preparing the resistance surface
\addcontentsline{toc}{subsubsection}{Step 1:  Preparing the resistance surface}


The MPG has typically been constructed using least-cost path links between the perimeters of habitat patches.  This implies that landscape structure in the "matrix" between patches is influencing movement, and that the organism in question is on average minimizing its costs when moving through this matrix (an assumption possibly appropriate for terrestrial animals, and terrestrial animal-dispersed plants).  Equally, MPGs can be constructed using Euclidean links, where the only influence of the matrix on movement is the effect of spatial separation (i.e. distance it presents between neighbouring habitat).  In the following example we illustrate just the case where links are least-cost paths on a resistance surface.  Euclidean links can be produced by passing a uniform cost surface (a constant raster), and a raster describing the patches.  The only difference in analysis is at the first step below.


We begin by loading a landscape raster distributed with the package.  Note that any raster format readable using the \verb!raster! package can be used here.  The \verb!.asc! format rasters distributed with the package are \verb!ESRI ArcASCII! format.

<<echo=TRUE,print=FALSE>>=
patchy <- raster(system.file("extdata/patchy.asc", package="grainscape"))
@

Then, for convenience, we use R to turn this raster into a resistance surface.  In this example we will assume the feature class 1 are the patches, so we will set them to resistance value also equal to 1 (i.e. no additional resistance to movement than distance alone).  The river, feature class 2, is assigned the highest resistance of 10.  Other features are assigned values in between.  The parameterization of resistance surfaces is itself a big topic \citep{zeller_etal_2012}.

<<echo=TRUE,print=FALSE>>=
patchyCost <- reclassify(patchy, rcl=cbind(c(1,2,3,4,5), c(1, 10, 8, 3, 6)))
plot(patchyCost)
@

\begin{figure}[p]
\begin{center}

<<fig=TRUE, echo=FALSE, print=FALSE, results=hide>>=
plot(patchyCost, main="")
@

\caption{Input raster resistance surface to create MPG.  Features with value of 1 will be the patches in the graph.  A river (dark green) has the highest resistance in this example.}
\label{fig:patchycost}
\end{center}
\end{figure}

The result is shown in Figure~\ref{fig:patchycost}.

\end{description}

\begin{description}
\item[Step 2] Extracting the MPG
\addcontentsline{toc}{subsubsection}{Step 2:  Extracting the MPG}


With a resistance surface in hand the next step is to create the MPG.  Basic use of the function, \verb!gsMPG()! to do this is shown here.  Here for simplicity we assume that all areas with the resistance value equal to 1 on the raster are patches.

<<echo=TRUE,print=FALSE>>=
#patchyMPG <- gsMPG(patchyCost, patch=patchyCost==1)
@

Note that we defined the patches by passing a binary raster \verb!patchyCost==1! as input.  If patches are to be defined in a different way (e.g. using resistance classes 1 and 2) then a binary patch raster can be produced as \verb!patch=patchyCost %in% c(1,2)!.  Equally, we could use the \verb!raster! package to load a binary raster produced manually in GIS software and specify the resulting raster object as the \verb!patch! parameter.

Upon execution of this function, \textsc{grainscape} calls \textsc{SELES}, a binary executable distributed with the package, in order to extract the graph, and then automatically imports the output of the SELES run back into R transparently.  More control can be had over this process if required (see manual).

\end{description}

\begin{description}
\item[Step 3] Quick visualization of the MPG
\addcontentsline{toc}{subsubsection}{Step 3:  Quick visualization of the MPG}


A quick way to visualize the MPG is provided in the \verb!gsMPG! object produced by \verb!gsMPG()!.

<<echo=TRUE,print=FALSE>>=
plot(patchyMPG$mpgPlot)
@

However, I've done something a little more advanced so that it shows up cleanly in the PDF you are now reading.  The result is shown in Figure~\ref{fig:mpgplot}.

\begin{figure}[p]
\begin{center}

<<fig=TRUE, echo=TRUE, print=FALSE, results=hide>>=
## Plot the patches / nodes
plot(patchyMPG$patchId, col="black", main="", legend=FALSE)
## Before plotting the links we'll make them wider so they print nicely
links <- patchyMPG$lcpPerimWeight > 0
links[raster::edge(links, type="outer")] <- 1
plot(links, col="darkgrey", add=TRUE, legend=FALSE)
@

\caption{A quick visualization of the MPG.  Black areas are patches (nodes or vertices) in the graph, and grey lines are links (edges) showing the least-cost path between the perimeters of the patches.  In depth discussion of how the MPG is generated can be found elsewhere \citep{fall_etal_2007}}
\label{fig:mpgplot}
\end{center}
\end{figure}
\end{description}

\begin{description}
\item[Step 4] Reporting on the MPG
\addcontentsline{toc}{subsubsection}{Step 4:  Reporting on the MPG}


Following extraction, the MPG is available as an \verb!igraph! object (see \verb!patchyMPG$mpg!) and can be analyzed using any of the functions in this package.  A quick way to report on the structure of the graph in tabular format is provided by the \textsc{grainscape} function \verb!gsGraphDataFrame()!:

\verb!gsGraphDataFrame(patchyMPG)!

The output shows the structure of the vertices (nodes) and their attributes under the list element \verb!$v! as well as the structure of the graph in the form of an edge list (i.e. pairs of edges \verb!e1! and \verb!e2! that are connected) and associated edge (link) attributes under the list element \verb!$e!.  Note that only the first three lines of each has been reproduced here.  Please see the manual for the interpretation of the attributes.

Note! however that the attribute \verb!eucPerimWeight! is not the same as extracting the MPG on a uniform (Euclidean) cost surface.  This attribute describes the Euclidean distance between patch perimeters given the Voronoi tessellation of the cost surface (the dual of the MPG).  Please see the next tutorial for information about the Voronoi tessellation.

<<echo=FALSE,print=FALSE>>=
tempResult <- gsGraphDataFrame(patchyMPG)
tempResult[[1]]$v <- tempResult[[1]]$v[1:3, ]
tempResult[[1]]$e <- tempResult[[1]]$e[1:3, ]
tempResult
@
\end{description}

\begin{description}
\item[Step 5] Thresholding the MPG
\addcontentsline{toc}{subsubsection}{Step 5:  Thresholding the MPG}


A frequent step in the analysis of a patch-based landscape graph is to threshold the graph into a series of subgraphs or components representing connected areas for an organism \citep{galpern_etal_2011, galpern_etal_2012, urban_keitt_2001}.  This has sometimes been called a scalar analysis \citep{brooks_2003}.

The function \verb!gsThreshold()! provides a way to conduct a scalar analysis at multiple scales.  Here we ask for 5 thresholds, and the function finds five approximately evenly-spaced threshold values in link length:

\verb!scalarAnalysis <- gsThreshold(patchyMPG, nThresh=5)!

<<echo=FALSE,print=FALSE>>=
scalarAnalysis <- gsThreshold(patchyMPG, nThresh=5)
scalarAnalysis$summary
@

The \verb!$summary! of this analysis can be plotted to explore scales of aggregation in the landscape.  Figure~\ref{fig:scalesaggregation} shows a scalar analysis of this landscape with 100 thresholds, where the response variables is the number of components or subgraphs created by the thresholding.

\begin{figure}[p]
\begin{center}

<<fig=TRUE, echo=TRUE, print=FALSE, results=hide>>=
scalarAnalysis <- gsThreshold(patchyMPG, nThresh=100)
plot(scalarAnalysis$summary[, "maxLink"],
     scalarAnalysis$summary[, "nComponents"],
     xlab="Link Threshold (resistance units)",
     ylab="Number of components", type="l")
@

\caption{A scalar analysis at 100 thresholds of the MPG in Figure~\ref{fig:mpgplot}.  When the landscape is a single component at higher link thresholds all patches are completely connected.  As an example, an organism able to disperse 200 resistance units would experience this landscape as 6 connected regions.}
\label{fig:scalesaggregation}
\end{center}
\end{figure}

Other independent variables about the components (e.g. area of patches) could, of course, be calculated by processing the thresholded graphs \verb!scalarAnalysis$th! and their attributes using the \verb!igraph! function \verb!clusters()!.

\end{description}

\begin{description}
\item[Step 6] Visualizing a thresholded graph
\addcontentsline{toc}{subsubsection}{Step 6:  Visualizing a thresholded graph}


Consider an organism able to disperse a maximum of 200 resistance units.  According to Figure~\ref{fig:scalesaggregation} this organism would experience this landscape as 6 connected regions.  This is visualized in Figure~\ref{fig:thresholdedgraph}.

\begin{figure}[p]
\begin{center}

<<fig=TRUE, echo=TRUE, print=FALSE, results=hide>>=
## Plot the patches
plot(patchyMPG$patchId, main="", col="black", legend=FALSE)
## Plot the links, but emphasize them first for printing
thresholdLink <- patchyMPG$lcpPerimWeight <= 200
thresholdLink[thresholdLink==0] <- NA
thresholdLink[raster::edge(thresholdLink, type="outer")] <- 1
plot(thresholdLink, add=TRUE, col="darkgrey", legend=FALSE)
@

\caption{The thresholded MPG depicted with a link length of 200 resistance units.  An organism that can disperse a maximum of 200 resistance units would experience this landscape as 6 connected regions in the depicted spatial configuration.  Note that the plotting has been made a little more complicated than it needs to be in order to emphasize the links for printing.}
\label{fig:thresholdedgraph}
\end{center}
\end{figure}


\end{description}

\begin{description}
\item[Step 7] Next steps
\addcontentsline{toc}{subsubsection}{Step 7:  Next Steps}

With the MPG in hand, all sorts of subsequent analyses about landscape connectivity are possible.  Grains of connectivity (GOC) the subject of the next three tutorials is an example of using the MPG and its complement the Voronoi tessellation.

When programming your own analyses in R based on the MPG it is helpful to observe that the \verb!patchyMPG$patchId! and \verb!patchyMPG$lcpLinkId! rasters contain the numerical IDs of the patches (nodes) and links respectively.  These are are also contained as attributes in the \verb!igraph! object \verb!patchyMPG$mpg!. Using these three data objects together gives flexibility to visualize any graph analysis.  To explore the attributes further use \verb!gsGraphDataFrame()!.
\end{description}
\end{description}


\begin{description}
\item[Tutorial 2] Patch-based grains of connectivity
\addcontentsline{toc}{subsection}{Patch-based grains of connectivity}

Grains of connectivity (hereafter GOC) was initially developed in two papers \citep{galpern_manseau_2013, galpern_etal_2012}.  Please refer to these papers for much more detail on this method.  In summary, grains of connectivity describes a tessellation of functionally-connected regions of the landscape.  These may be especially useful for modelling landscape connectivity for highly-mobile terrestrial organisms that are not obligate patch occupants.

Patch-based GOC, shown in this tutorial, may be most relevant for oganisms that have patch affinities, but experience "habitat" as a probabilistic surface.  Lattice GOC, shown in the next tutorial, is likely more appropriate when a patch affinity cannot be supported (i.e. there is no resource for which proximity is demonstrably important).  This may also be the case when modelling landscape connectivity for large terrestrial mammals.

\begin{description}
\item[Step 1]  Begin with an MPG
\addcontentsline{toc}{subsubsection}{Step 1:  Begin with an MPG}

Here, we repeat the steps in Tutorial 1 for the same resistance surface.  Any of the variations imaginable for the MPG are equally valid here.

<<echo=TRUE,print=FALSE>>=
patchy <- raster(system.file("extdata/patchy.asc", package = "grainscape"))
patchyCost <- reclassify(patchy, rcl = cbind(c(1,2,3,4,5), c(1, 10, 8, 3, 6)))
#patchyMPG <- gsMPG(patchyCost, patch = (patchyCost == 1))
@
\end{description}

\begin{description}
\item[Step 2]  Exploring the Voronoi tessellation
\addcontentsline{toc}{subsubsection}{Step 2:  Exploring the Voronoi tessellation}

Before we build the GOC graph, we should explore the essential building block of GOC, which is the Voronoi tessellation.  This particular Voronoi tessellation was first described elsewhere \citep{fall_etal_2007} and is the complement of the MPG.  It is found by finding the region of proximity in resistance units around a resource patch.  In contrast to a typical Voronoi tessellation where the generators are points and distance is Euclidean, this tessellation uses two-dimensional patches as generators and distance is calculated in cost or resistance space.  Ultimately, the tessellation is found in \textsc{SELES} using a marching algorithm.

The Voronoi tessellation was extracted by \verb!gsMPG()! in order to build the MPG.  It can be plotted simply as follows:

\verb!plot(patchyMPG$voronoi)!

A plot with the Voronoi tessellation and the patches superimposed is shown in Figure~\ref{fig:voronoitessellation}.

\begin{figure}[p]
\begin{center}

<<fig=TRUE, echo=TRUE, print=FALSE, results=hide>>=
plot(patchyMPG$voronoi, main="")
plot(patchyMPG$patchId, add=TRUE, col="black", legend=FALSE)
@

\caption{A Voronoi tessellation.  This is the complement of the MPG.  The patches are used as generators, and regions of proximity (polygons of different colours) are found in cost or resistance units.  The method was first described by \citep{fall_etal_2007}.}
\label{fig:voronoitessellation}
\end{center}
\end{figure}

\end{description}

\begin{description}
\item[Step 3] Building GOC models
\addcontentsline{toc}{subsubsection}{Step 3: Building GOC models}

GOC analysis is essentially a scalar or thresholding analysis (see \verb!gsThreshold()! and Tutorial 1) except the graph being thresholded is one of Voronoi polygons rather than patches.  In particular, it is the MPG of Voronoi polygons that is thresholded.  As links are added, and Voronoi polygons linked, the relevant polygons are combined describing larger connected regions.  An additional step is that the links connecting a pair of polygons are the mean value of all links connecting any patches in each of the two polygons from the MPG \citep{galpern_etal_2012}.

The function \verb!gsGOC()! builds GOC models at multiple thresholds.  As with \verb!gsThreshold()! we can specify the number of thresholds, or grains of connectivity models, we want to create using the \verb!nThresh! parameter.

\verb!patchyGOC <- gsGOC(patchyMPG, nThresh=100)!
<<echo=FALSE,print=FALSE>>=
#patchyGOC <- gsGOC(patchyMPG, nThresh=100)
@

\end{description}

\begin{description}
\item[Step 4] Visualizing a GOC model
\addcontentsline{toc}{subsubsection}{Step 4: Visualizing a GOC model}

To get a quick sense of the connected regions described by a GOC model at a given threshold (or scale of movement) we can use the function \verb!gsGOCVisualize()!.  This example uses the functions plotting mechanism to plot the 62nd threshold in the \verb!patchyGOC! object.

\verb!gsGOCVisualize(patchyGOC, whichThresh=4, doPlot=TRUE)!

Figure~\ref{fig:gocthresh} shows the resulting plot.

\begin{figure}[p]
\begin{center}

<<fig=TRUE, echo=TRUE, print=FALSE, results=hide>>=
gsGOCVisualize(patchyGOC, whichThresh=62, doPlot=TRUE)
@

\caption{A visualization of a GOC model.  In this case it is the 62nd scale or threshold extracted, which represents a link threshold of 168 resistance units, and a landscape of 6 components.  Voronoi polygons imply regions that are functionally-connected at the given movement threshold.}
\label{fig:gocthresh}
\end{center}
\end{figure}
\end{description}

\begin{description}
\item[Step 5] Identifying locations on a GOC model
\addcontentsline{toc}{subsubsection}{Step 5: Identifying locations on a GOC model}

Organisms have locations in space.  It is often necessary to know which connected region contains a given location in a GOC model.  This can be done using the function \verb!gsGOCPoints()!.  First we create a thousand random locations that are on the landscape, and then run the function

<<echo=TRUE,print=FALSE>>=
loc <- cbind(runif(1000)*399, runif(1000)*-399)
locGOC <- gsGOCPoint(patchyGOC, loc)
@

The resulting object \verb!locGOC! reports on the polygon which contains each location at each threshold (\verb!pointPolygon!) as well as several other variables describing features of the polygons in which point locations are contained.

\end{description}

\begin{description}
\item[Step 6] Finding the distance between points on a GOC model
\addcontentsline{toc}{subsubsection}{Step 6: Finding the distance between points on a GOC model}

As mentioned at an earlier step, at each threshold (or scale) there is also a GOC graph describing the relationships among the polygons.  We can find the distance between the polygons containing pairs of points using the \verb!gsGOCDistance()! function.  This may be particularly useful in certain types of landscape genetic analyses where genetic distances are correlated with landscape distances \citep{galpern_etal_2012}.  A key advantage is that thresholding permits scaling of these distances for coarse representations of the landscape, removing variation from the calculation of distance that may be uncorrelated with dispersal.

Here we'll use four locations on the landscape.

<<echo=TRUE,print=FALSE>>=
loc <- rbind(c(100,-100), c(200, -200), c(300, -300), c(100, -300))
distGOC <- gsGOCDistance(patchyGOC, loc)
@

The resulting object \verb!locGOC! reports on the pairwise distances in accumulated resistance units between each of those four points given the GOC model at each threshold.  The results for the 62nd threshold are shown, where the row and column names give the \verb!polygonId! containing each of the four points.

<<echo=TRUE,print=FALSE>>=
distGOC$th[[62]]
@

\end{description}

\end{description}


\begin{description}
\item[Tutorial 3] Lattice grains of connectivity
\addcontentsline{toc}{subsection}{Lattice grains of connectivity}

A lattice grains of connectivity model uses a lattice of focal points superimposed over the landscape rather than patches on the landscape as nodes in the MPG.  These points are also the generators used in the Voronoi tessellation.  The result is a more generic way to scale up a resistance surface to coarser scales, without requiring assumptions about a particular habitat type that may be "focal" for connectivity.  All that is required for analysis is an input resistance surface, reducing the ecological parameter set of the model.

\begin{description}
\item[Step 1] Building a lattice GOC model
\addcontentsline{toc}{subsubsection}{Step 1: Building a lattice GOC model}

For lattice GOC modelling a decision is required regarding the spacing of points in the lattice.  This amounts to a decision about the finest scale, or grain, to be analyzed.  Analysis time quickly increases as more nodes (lattice points) are included, so this decision should be made carefully.

The steps in extracting the MPG are the same as before, except instead of specifying a raster for the \verb!patch! parameter, we specify an integer.  This integer gives the spacing in cells between focal points in the square lattice.  Thus a square raster of \verb!400! cells in dimension, and \verb!patch=40! produces a lattice of \verb!10 * 10 = 100! focal points.

<<echo=TRUE,print=FALSE>>=
#patchyMPGLattice <- gsMPG(patchyCost, patch=40)
@

Let's check how many focal points were actually used in this case:

<<echo=TRUE,print=FALSE>>=
max(patchyMPGLattice$patchId[], na.rm=TRUE)
@

Which is what we expected.  A visualization of these focal points and the MPG is shown in Figure~\ref{fig:latticempg}.

\begin{figure}[p]
\begin{center}

<<fig=TRUE, echo=TRUE, print=FALSE, results=hide>>=
## Plot the links but make them wider so they print nicely
links <- patchyMPGLattice$lcpPerimWeight > 0
links[raster::edge(links, type="outer")] <- 1
plot(links, main="", col="darkgrey", legend=FALSE)
## Add the focal points.  We'll get the locations from the MPG object
focalPts <- cbind(V(patchyMPGLattice$mpg)$centroidX, V(patchyMPGLattice$mpg)$centroidY)
points(focalPts, pch="+", cex=1.25)
@

\caption{A visualization of an MPG of a lattice of focal points for the resistance surface in Figure~\ref{fig:patchycost}.  Again, we have complicated plotting a bit to emphasize the links better.}
\label{fig:latticempg}
\end{center}
\end{figure}

\end{description}

\begin{description}
\item[Step 2] Producing and visualizing a lattice GOC model
\addcontentsline{toc}{subsubsection}{Step 2: Producing and visualizing a lattice GOC model}

These steps proceeds much as with the patch-based GOC model.  The next step is to produce GOC model.

<<echo=TRUE,print=FALSE>>=
#patchyGOCLattice <- gsGOC(patchyMPGLattice, nThresh=100)
@

Visualization of the Voronoi tessellation for the 35th threshold is shown in Figure~\ref{fig:goclatticethresh}.

\begin{figure}[p]
\begin{center}

<<fig=TRUE, echo=TRUE, print=FALSE, results=hide>>=
plot(gsGOCVisualize(patchyGOCLattice, whichThresh=35)$voronoi,
     col=sample(terrain.colors(100)), main="whichThresh=35")
@

\caption{A visualization of a GOC model.  In this case it is the 35th scale or threshold extracted, which represents a link threshold of 122 resistance units.  Voronoi polygons imply regions that are functionally-connected at this movement threshold.  It is easy to imagine, here, how using more lattice points makes it possible to define grains of connectivity with higher resolution.}
\label{fig:goclatticethresh}
\end{center}
\end{figure}

\end{description}

\begin{description}
\item[Step 3] Next steps
\addcontentsline{toc}{subsubsection}{Step 3: Next steps}

Further analyses can proceed as with the patch-based GOC model.  For example \verb!gsGOCPoints! and \verb!gsGOCDistance! can be used, as can other \verb!igraph! analyses of the graphs contained in \verb!patchyGOCLattice$th! and \verb!patchMPGLattice$mpg!.

\end{description}

\end{description}


\begin{description}
\item[Tutorial 4] Advanced visualization for grains of connectivity models
\addcontentsline{toc}{subsection}{Advanced visualization for grains of connectivity models}

So far we have been visualizing the products of analysis using raster formats.  Since all analyses take place in raster format this has the added advantage of speed.  However, for publications, or on-screen visuals, it tends to be better to have high resolution vector representations; particularly of the Voronoi polygons, as this makes it easier to understand what they show without confusing blocks of colour.

In the two sections of this tutorial we demonstrate how to use the \textsc{rgeos} package in R to produce polygon representations of the Voronoi polygons in a GOC model, as well as using a \textsc{grainscape} function intended for advanced visualizations.

Beware!  One caution is that the \textsc{rgeos} package continues to have memory leak problems from its parent C \textsc{GEOS} library which extend to \textsc{grainscape}.  Occasionally when running analyses, particularly with thousands of nodes (i.e. polygons), \textsc{rgeos} can consume all available memory and lead to a crash of the R instance.  Also, when running multiple visualizations in succession it is often necessary to terminate the R instance to free up memory before running a subsequent visualization.

\begin{description}
\item[Section 1] Visualizing GOC models with vectorized Voronoi polygons
\addcontentsline{toc}{subsubsection}{Section 1:  Visualizing GOC models with vectorized Voronoi polygons}

For final analyses where visualization is a goal, build the GOC model with the \verb!sp=TRUE! parameter set.  Also, the \textsc{rgeos} package must be installed.  Here, we do this for both the patch-based and lattice GOC models of Tutorials 2 and 3, respectively.  Note that this can be very slow, consuming orders of magnitude more computational time!

<<echo=TRUE,print=FALSE>>=
#patchyGOC_SP <- gsGOC(patchyMPG, nThresh=100, sp=TRUE)
#patchyGOCLattice_SP <- gsGOC(patchyMPGLattice, nThresh=100, sp=TRUE)
@

Note how we can now visualize the Voronoi tessellation also with the \verb!sp=TRUE! parameter to make things sharper.  Figure~\ref{fig:spvoronoi} shows this for the lattice GOC model at the finest threshold possible, superimposed over the input resistance surface used to generate the GOC model.

\begin{figure}[p]
\begin{center}

<<fig=TRUE, echo=TRUE, print=FALSE, results=hide>>=
plot(patchyCost, legend=FALSE, main="")
plot(gsGOCVisualize(patchyGOCLattice_SP, whichThresh=1, sp=TRUE)$voronoiSP,
    add=TRUE)
focalPts <- cbind(V(patchyMPGLattice$mpg)$centroidX, V(patchyMPGLattice$mpg)$centroidY)
points(focalPts, pch="+", cex=1.25)
@

\caption{A visualization of a lattice GOC model using vectorized Voronoi polygons, superimposed over the input resistance surface.  In this case the Voronoi polygons show the finest grain possible using the 100 point lattice (+) initially specified.  Plotting only the outlines of the Voronoi polygons makes it easier to show other information on this map (e.g. resistance surface) and retain clarity.  Recall, when interpreting this figure, that the polygons show regions of proximity from each focal lattice point given distance in resistance units.}
\label{fig:spvoronoi}
\end{center}
\end{figure}

\end{description}

\begin{description}
\item[Section 2] Visualizing the complete GOC model, corridors and shortest paths
\addcontentsline{toc}{subsubsection}{Section 2:  Visualizing the complete GOC model, corridors and shortest paths}

\textsc{grainscape} provides a function called \verb!gsGOCCorridor()! to simplify advanced visualizations when the goal is to show a GOC, the graph connecting Voronoi polygons and a shortest path or corridor between certain points on the landscape.

Figure~\ref{fig:corridorpatch} shows a visualization for the patch-based GOC model, and Figure~\ref{fig:corridorlattice} shows a visualization for the lattice GOC model.  Finally Figure~\ref{fig:corridorfancy} demonstrates how to take manual control of the visualization to liven up the product!

\begin{figure}[p]
\begin{center}

<<fig=TRUE, echo=TRUE, print=FALSE, results=hide>>=
loc <- rbind(c(50, -350), c(350, -50))
corridor1 <- gsGOCCorridor(patchyGOC_SP, whichThresh=1, coords=loc, doPlot=TRUE)
points(loc, pch=c("P", "Q"), cex=1.25)
mtext(paste("Shortest path between P and Q:",
    round(corridor1$corridorLength, 2), "resistance units",
    sep=" "),
    side=1)
@

\caption{A visualization of the complete patch-based GOC model at its finest scale and the shortest path or least-cost corridor given the GOC graph between two locations on the map (P and Q) at this scale.  Grey regions are Voronoi polygons in the patch-based GOC model.}
\label{fig:corridorpatch}
\end{center}
\end{figure}

\begin{figure}[p]
\begin{center}

<<fig=TRUE, echo=TRUE, print=FALSE, results=hide>>=
loc <- rbind(c(50, -350), c(350, -50))
corridor1 <- gsGOCCorridor(patchyGOCLattice_SP, whichThresh=45,
   coords=loc, doPlot=TRUE)
points(loc, pch=c("P", "Q"), cex=1.25)
mtext(paste("Shortest path between P and Q:",
    round(corridor1$corridorLength, 2), "resistance units",
    sep=" "),
    side=1)
@

\caption{A visualization of the complete lattice GOC model at a relatively coarse scale and the shortest path or least-cost corridor given the GOC graph between two locations on the map (P and Q) at this scale.  Grey regions are Voronoi polygons in the lattice GOC model.}
\label{fig:corridorlattice}
\end{center}
\end{figure}


\begin{figure}[p]
\begin{center}

<<fig=TRUE, echo=TRUE, print=FALSE, results=hide>>=
tiny <- raster(system.file("extdata/tiny.asc", package = "grainscape"))
## Create a resistance surface from a raster using an is-becomes reclassification
#tinyCost <- reclassify(tiny, rcl=cbind(c(1, 2, 3, 4), c(1, 5, 10, 12)))
## Produce a patch-based MPG where patches are resistance features=1
#tinyPatchMPG <- gsMPG(cost=tinyCost, patch=tinyCost==1)
## Extract a representative subset of 5 grains of connectivity using sp=TRUE
tinyPatchGOC <- gsGOC(tinyPatchMPG, nThresh=5, sp=TRUE)
## Visualization of a corridor
corridorStartEnd <- rbind(c(10,10), c(90,90))
tinyPatchCorridor <- gsGOCCorridor(tinyPatchGOC, whichThresh=3,
    coords=corridorStartEnd)
plot(tinyPatchCorridor$voronoiSP, col="lightgrey", border="white", lwd=2)
plot(tinyPatchCorridor$linksSP, col="darkred", lty="dashed", add=TRUE)
plot(tinyPatchCorridor$nodesSP, col="darkred", pch=21, bg="white", add=TRUE)
plot(tinyPatchCorridor$shortestLinksSP, col="darkred", lty="solid",
    lwd=2, add=TRUE)
plot(tinyPatchCorridor$shortestNodesSP, col="darkred", pch=21,
    bg="darkred", add=TRUE)
mtext(paste("Corridor shortest path length:",
             round(tinyPatchCorridor$corridorLength, 2),
             "resistance units"), side=1)
@

\caption{More control over a corridor visualization using an example from the manual, and the tiny.asc resistance surface}
\label{fig:corridorfancy}
\end{center}
\end{figure}

\end{description}

\end{description}

\begin{description}
\item[Tutorial 5] The minimum planar graph extracted in overlapping strips for applications in large landscapes
\addcontentsline{toc}{subsection}{The minimum planar graph extracted in overlapping strips for applications in large landscapes}

Applications of graph-based connectivity analyses in ecology, evolution, and conservation biology often require that the MPG be constructed for large landscapes with many patches. Due to memory limitations associated with SELES, these large landscape are best analyzed in sections. To do so, the landscape is sectioned into overlapping strips and the MPG is constructed in each one either sequentially or in parallel. Once the MPGs are constructed they are then stitched together by aligning the Voronoi tessellations of the cost surfaces in overlapping regions. The landscape must be rectangular for the sectioning and subsequent stitching of the MPGs.

\begin{description}
\item[Step 1] Preparing the resistance surface
\addcontentsline{toc}{subsubsection}{Step 1: Preparing the resistance surface}

This is the same as Step 1 in Tutorial 1. For this example we will use the another landscape raster distributed with the package also in ESRI ArcASCII format.  This is illustrated in Figure~\ref{fig:resistTutorial5}.

\begin{figure}[p]
\begin{center}

<<fig=TRUE, echo=TRUE, print=FALSE, results=hide>>=
fragmented <- raster(system.file("extdata/fragmented.asc", package = "grainscape"))
fragmentedCost <- reclassify(fragmented, rcl = cbind(c(1,2,3,4,5), c(1, 10, 8, 3, 6)))
plot(fragmentedCost, main = "")
@

\caption{The resistance surface used in Tutorial 5}
\label{fig:resistTutorial5}
\end{center}
\end{figure}

\item[Step 2] Creating a patch ID layer
\addcontentsline{toc}{subsubsection}{Step 2: Creating a patch ID layer}

In order to stitch together MPGs constructed in the overlapping strips, we must provide a patch id layer which will allow us to align the Voronoi tessellations. Patches are defined as contiguous cells (based on either 4 or 8 neighbours) and each patch has a unique id (all raster cells of a patch have the same id). Here for simplicity we create a patch id layer using the \verb!clump()! function in the raster package, assuming that all areas with resistance value equal to 1 on the cost raster are patches. Equally, we could use the raster package to load a patch id raster produced manually in GIS software and specify the resulting raster object as the patch id parameter.  See Figure~\ref{fig:patchIDLayer} for an illustration of the patch ID layer.

\begin{figure}[p]
\begin{center}

<<fig=TRUE, echo=TRUE, print=FALSE, results=hide>>=
fragmentedPatchId <- clump(fragmentedCost==1, directions=8, gaps=FALSE)
fragmentedPatchId[is.na(fragmentedPatchId[])] <- 0
plot(fragmentedPatchId, main="")
@

\caption{The patch ID layer}
\label{fig:patchIDLayer}
\end{center}
\end{figure}


\item[Step 3] Extracting the minimum planar graph
\addcontentsline{toc}{subsubsection}{Step 3: Extracting the minimum planar graph}

With the resistance surface and patch id rasters, we must then decide on the number of strips and the percent overlap of strips that we want to use to construct the MPG using the \verb!gsMPGstitch()! function. The resulting stitched MPG will most closely match the true MPG (i.e., the MPG constructed if the landscape were processed in a single pass using the \verb!gsMPG()! function), the fewer the number of strips and the higher the percent overlap between them. Basic use of the \verb!gsMPGstitch()! function is shown here using 3 strips with 50 percent overlap extracted sequentially.


<<echo=TRUE,print=FALSE>>=
fragmentedMPGstitch <- gsMPGstitch(cost=fragmentedCost, patchid=fragmentedPatchId, numStrips=3, percentOverlap=50)
@

To compare this result we can construct the MPG in a single pass using the \verb!gsMPG()! function as follows.  The resulting MPGs extracted with the functions \verb!gsMPGstitch()! and \verb!gsMPG()! are shown in Figure~\ref{fig:MPGcomparison}

\begin{figure}[p]
\begin{center}

<<fig=TRUE, echo=TRUE, print=FALSE, results=hide>>=
par(mfrow=c(1,2))

## Plot the patches / nodes of fragmentedMPGstitch
plot(fragmentedMPGstitch$patchId, col="black",
  main="gsMPGstitch(numStrips=3, percentOverlap=50)",
  legend=FALSE)
## Before plotting the links of fragmentedMPGstitch
## we'll make them wider so they print nicely
links <- fragmentedMPGstitch$lcpPerimWeight > 0
links[raster::edge(links, type="outer")] <- 1
plot(links, col="darkgrey", add=TRUE, legend=FALSE)

## Plot the patches / nodes of fragmentedMPG
plot(fragmentedMPG$patchId, col="black", main="gsMPG()", legend=FALSE)
## Before plotting the links of fragmentedMPG
## we'll make them wider so they print nicely
links <- fragmentedMPG$lcpPerimWeight > 0
links[raster::edge(links, type="outer")] <- 1
plot(links, col="darkgrey", add=TRUE, legend=FALSE)
@

\caption{A comparison of MPGs produced using \verb!gsMPGstich()! and the single pass version \verb!gsMPG()!}
\label{fig:MPGcomparison}
\end{center}
\end{figure}


item[Step 4] Visualizing, reporting, thresholding and further analysis of the MPG
\addcontentsline{toc}{subsubsection}{Step 4: Visualizing, reporting, thresholding and further analysis of the MPG}

The MPG extraction using the function gsMPGstitch() produces a gsMPG object that is the same form as that created using gsMPG(). All subsequent visualizations, manipulations, and analyses are therefore identical to those described in Steps 3-7 in Tutorial 1 The minimum planar graph.

Note that when we compare the MPGs constructed with the functions \verb!gsMPGstitch()! and \verb!gsMPG()!, the patch ids are different.

<<echo=TRUE,print=FALSE>>=
gsGraphDataFrame(fragmentedMPGstitch)
gsGraphDataFrame(fragmentedMPG)
@

\end{description}

\end{description}

\begin{thebibliography}{99}
\bibitem[Brooks(2003)]{brooks_2003}Brooks, C.P. (2003). A scalar analysis of landscape connectivity. Oikos 102:433-439.
\bibitem[Fall and Fall(2001)]{fall_fall_2001}Fall, A. and J. Fall. (2001). A domain-specific language for models of landscape dynamics. Ecological Modelling 141:1-18.
\bibitem[Fall et al.(2007)]{fall_etal_2007}Fall, A., M.J. Fortin, M. Manseau, and D. O'Brien. (2007). Spatial graphs: Principles and applications for habitat connectivity. Ecosystems 10:448-461.
\bibitem[Galpern and Manseau(2013)]{galpern_manseau_2013}Galpern, P., M. Manseau. (2013).  Modelling the influence of landscape connectivity on animal distribution: a functional grain approach.  Ecography.  In press.
\bibitem[Galpern et al.(2012)]{galpern_etal_2012}Galpern, P., M. Manseau, and P.J. Wilson. (2012). Grains of connectivity: analysis at multiple spatial scales in landscape genetics. Molecular Ecology 21:3996.4009.
\bibitem[Galpern et al.(2011)]{galpern_etal_2011}Galpern, P., M. Manseau, and A. Fall. (2011). Patch-based graphs of landscape connectivity: A guide to construction, analysis and application for conservation. Biological Conservation 144:44-55.
\bibitem[Pascual-Hortal and Saura(2006)]{pascualhortal_saura_2006}Pascual-Hortal, L. and S. Saura. (2006). Comparison and development of new graph-based landscape connectivity indices: towards the priorization of habitat patches and corridors for conservation. Landscape Ecology 21:959-967.
\bibitem[Urban and Keitt(2001)]{urban_keitt_2001}Urban, D. and T. Keitt. (2001). Landscape connectivity: A graph-theoretic perspective. Ecology 82:1205-1218.
\bibitem[Zeller et al.(2012)]{zeller_etal_2012}Zeller, K.A., K. McGarigal, and A.R. Whiteley. (2012). Estimating landscape resistance to movement: a review. Landscape Ecology:1-21.
\end{thebibliography}
\end{document}





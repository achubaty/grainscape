<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Calculating the minimum planar graph and generating Voronoi tessellations • grainscape</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.3.7/flatly/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha256-U5ZEeKfGNOja007MMD3YBI0A3OSZOQbeG6z2f2Y0hu8=" crossorigin="anonymous"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" integrity="sha256-FiZwavyI2V6+EXO1U+xzLG3IKldpiTFf3153ea9zikQ=" crossorigin="anonymous"></script><!-- sticky kit --><script src="https://cdnjs.cloudflare.com/ajax/libs/sticky-kit/1.1.3/sticky-kit.min.js" integrity="sha256-c4Rlo1ZozqTPE2RLuvbusY3+SU1pQaJC0TjuhygMipw=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Calculating the minimum planar graph and generating Voronoi tessellations">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">grainscape</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.4.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/MPG_algorithm.html">Calculating the minimum planar graph and generating Voronoi tessellations</a>
    </li>
    <li>
      <a href="../articles/grainscape_vignette.html">Modelling, visualization and analysis with the `grainscape` package</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/achubaty/grainscape">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>Calculating the minimum planar graph and generating Voronoi tessellations</h1>
                        <h4 class="author">Sam Doctolero and Alex M Chubaty</h4>
            
            <h4 class="date">2019-08-05</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/achubaty/grainscape/blob/master/vignettes/MPG_algorithm.Rmd"><code>vignettes/MPG_algorithm.Rmd</code></a></small>
      <div class="hidden name"><code>MPG_algorithm.Rmd</code></div>

    </div>

    
    

<div id="overview" class="section level2">
<h2 class="hasAnchor">
<a href="#overview" class="anchor"></a>Overview</h2>
<p>The Minimum Planar Graph (MPG) is a spatial representation of a mathematical graph or network that is useful for modelling dense two-dimensional landscape networks. It can efficiently approximate pairwise connections between graph nodes, and this can assist in the visualization and analysis of how a set of patches is connected. The MPG also has the useful property that the proximity, size and shape of patches in the network combined with the pattern of resistance presented by the landscape collectively influence the paths among patches and the end-points of those links. In this sense the MPG can be said to be spatially-explicit, and therefore to be a property of the entire landscape under analysis (or alternatively a property of the digital resistance map used to represent the landscape).</p>
<p>The Minimum Planar Graph (MPG) achieves this spatially-explicit property by finding Voronoi polygons that describe regions of proximity in resistance units around focal patches. The algorithm that is used to find the Voronoi boundaries and approximate the least cost-paths between patches and their end-points is described below.</p>
<p>In <code>grainscape</code>, the boundaries of Voronoi polygons are found by using a spreading or marching algorithm. This is done beginning in each perimeter cell of a patch and spreading out to adjacent cells that are not part of any patch and have not been visited yet by the algorithm. These cells are then given a patch ID to mark the Voronoi territory. A Voronoi boundary is found when a cell is visited twice by two different Voronoi territories or IDs originating from different patches.</p>
<p>Using a marching algorithm to find the Voronoi boundaries makes it possible to implement a linking algorithm that can run in parallel with the marching algorithm. As a cell is spread into (let’s call it a child cell) it then creates a link or connection between the child cell and the cell that it spread from, which we call a parent cell.</p>
<p>Finding the least-cost path in this way is only possible because the algorithm stores the child cells (which will eventually become parent cells) in a queuing table that sorts the cells in a certain order. The child cells are sorted by increasing Euclidean distance between the child cell and their origin cell, the perimeter cell that the connection originally spawned from. A link or path between patches is then created at the first Voronoi boundary between two patches.</p>
<p>The MPG algorithm has the following general steps. These are represented in more detail in a flow chart in Figure 1.</p>
<ol style="list-style-type: decimal">
<li>Create Active Cells.</li>
<li>Check if the Active Cells are ready to spread.</li>
<li>Spread to all 4 adjacent cells for all the Active Cells that ready to spread.</li>
<li>The cells that have been recently spread in to become new Active Cells.</li>
<li>Repeat.</li>
</ol>
<div class="figure">
<img src="figure_HabConnFlowchart.jpg" alt="Overview of the MPG algorithm." style="height:90.0%"><p class="caption">Overview of the MPG algorithm.</p>
</div>
<p>The linking algorithm is embedded within the spreading functions of the MPG algorithm. When an Active Cell spreads a link map creates a connection between the parent Active Cell to the new (child) Active Cell. Linking is assisted by the queue when finding the least-cost paths.</p>
</div>
<div id="technical-reference-to-the-mpg-engine-written-in-c" class="section level2">
<h2 class="hasAnchor">
<a href="#technical-reference-to-the-mpg-engine-written-in-c" class="anchor"></a>Technical reference to the MPG engine written in C++</h2>
<p>The following is intended to provide an overview of the C++ engine provided by the package that implements the MPG algorithm. It may be useful for those who wish to implement MPG extraction in other programming languages. Reading and interpretation of this section is not required for the use of <code>grainscape</code> in R. An interface to this code has been abstracted to R functions using the <code>Rcpp</code> package.</p>
<div id="terminology" class="section level3">
<h3 class="hasAnchor">
<a href="#terminology" class="anchor"></a>Terminology</h3>
<ul>
<li>
<em>Cell:</em> A box or element in a map.</li>
<li>
<em>Active Cell:</em> A type of cell that is currently being evaluated. It refers to the child cell mentioned above.</li>
<li>
<em>Time:</em> An index of the iteration.</li>
<li>
<em>Object:</em> An instance of a certain data type, class, or data structure (<em>i.e.</em>, <code>Cell c</code>, <code>c</code> then is an object of type <code>Cell</code>).</li>
</ul>
<hr>
</div>
<div id="data-structures" class="section level3">
<h3 class="hasAnchor">
<a href="#data-structures" class="anchor"></a>Data Structures</h3>
<ul>
<li>
<code>Cell</code>: stores its own position (row and column) and an ID.</li>
<li>
<code>ActiveCell</code>: inherits the properties of a <code>Cell</code> and has its own properties such as <code>distance</code>, <code>originCell</code>, <code>parentCell</code>, <code>resistance</code>, and <code>time</code> (or iterations). This type of cell is used to keep track of which cells are currently being evaluated.</li>
<li>
<code>LinkCell</code>: inherits the properties of a <code>Cell</code> and has its own properties such as <code>cost</code>, <code>distance</code>, <code>fromCell</code>, and <code>originCell</code>. This type of cell is used to create <code>LinkMap</code>.</li>
</ul>
<div class="figure">
<img src="figure_cells_diagram.jpg" alt="Schematic representation of Cell type data structures."><p class="caption">Schematic representation of Cell type data structures.</p>
</div>
<ul>
<li>
<code>ActiveCellHolder</code>: a type of container that stores a vector of <code>ActiveCell</code>s in an order.</li>
<li>
<code>ActiveCellQueue</code>: contains an <code>ActiveCellHolder</code>. Its main purpose is to properly store the <code>ActiveCellHolder</code> in a vector in an order, increasing Euclidean distance.</li>
<li>
<code>InputData</code>: contains all the data that is needed for the engine to operate. The user of the engine has to create an instance of it and initialize all the properties before giving the address of the object to the engine’s constructor.</li>
<li>
<code>Link</code>: stores all the links (directly and indirectly) between the patches. Links are given a negative ID to distinguish them from patch IDs.</li>
<li>
<code>OutputData</code>: similar to <code>InputData</code> but it acts as a container for all the data that are calculated by the engine and gives that data to the user.</li>
<li>
<code>Patch</code>: a patch or a cluster are the habitats that are found in the resistance map, given a value for habitat.</li>
</ul>
<div class="figure">
<img src="figure_data_struct_diagram.jpg" alt="Schematic representation of additional data structures."><p class="caption">Schematic representation of additional data structures.</p>
</div>
<hr>
</div>
<div id="type-definitions" class="section level3">
<h3 class="hasAnchor">
<a href="#type-definitions" class="anchor"></a>Type Definitions</h3>
<ul>
<li>
<code>lcCol</code>: a vector of <code>LinkCells</code>.</li>
<li>
<code>LinkMap</code>: a vector of <code>lcCols</code>, which in turn creates a <code>Map</code>. This type stores the connections between cells.</li>
<li>
<code>flCol</code>: a vector of floating point values.</li>
<li>
<code>flMap</code>: a vector of <code>flCol</code>, which in turn creates a <code>Map</code> that contains floating point values in each element or cell.</li>
</ul>
<div class="figure">
<img src="figure_typedef_diagram.jpg" alt="Schematic representation of type definitions."><p class="caption">Schematic representation of type definitions.</p>
</div>
<hr>
</div>
<div id="the-engine-class" class="section level3">
<h3 class="hasAnchor">
<a href="#the-engine-class" class="anchor"></a>The <code>Engine</code> Class</h3>
<p>The main calculator of the program. It creates the minimum planar graph (MPG) using the MPG algorithm, finds least cost links or paths, and finds patches or clusters.</p>
<div class="figure">
<img src="figure_engine_class_diagram.jpg" alt="Schematic representation of the Engine Class"><p class="caption">Schematic representation of the Engine Class</p>
</div>
<div id="fieldsproperties" class="section level4">
<h4 class="hasAnchor">
<a href="#fieldsproperties" class="anchor"></a>Fields/Properties</h4>
<table class="table">
<colgroup>
<col width="35%">
<col width="28%">
<col width="36%">
</colgroup>
<thead><tr class="header">
<th><strong>Property</strong></th>
<th><strong>Data Type</strong></th>
<th><strong>Description</strong></th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>in_data</code></td>
<td>InputData Pointer</td>
<td>Points to an <code>InputData</code> object. This is where the engine gets all the initialization values from.</td>
</tr>
<tr class="even">
<td><code>out_data</code></td>
<td>OutputData Pointer</td>
<td>Points to an <code>OutputData</code> object. The engine stores all the calculated values in this variable.</td>
</tr>
<tr class="odd">
<td><code>maxCost</code></td>
<td>float</td>
<td>The maximum resistance or cost in the resistance map.</td>
</tr>
<tr class="even">
<td><code>costRes</code></td>
<td>float</td>
<td>The minimum resistance or cost in the resistance map.</td>
</tr>
<tr class="odd">
<td><code>active_cell_holder</code></td>
<td>ActiveCellQueue</td>
<td>Holds or stores all the <code>ActiveCells</code>.</td>
</tr>
<tr class="even">
<td><code>temporary_active_cell_holder</code></td>
<td>ActiveCellQueue</td>
<td>Similar to <code>active_cell_holder</code>, except it acts as an intermediate or temporary holder of <code>ActiveCells</code>. Required for vector resizing and comparing.</td>
</tr>
<tr class="odd">
<td><code>spread_list</code></td>
<td>vector of ActiveCells</td>
<td>Stores all the <code>ActiveCells</code> that are ready to spread to all 4 adjacent cells, if possible.</td>
</tr>
<tr class="even">
<td><code>iLinkMap</code></td>
<td>LinkMap</td>
<td>A map that keeps track of all the connections between cells due to the spreading and queuing functions.</td>
</tr>
<tr class="odd">
<td><code>voronoi_map</code></td>
<td>flMap</td>
<td>A map that contains floating point values, it stores the Voronoi boundaries/polygons.</td>
</tr>
<tr class="even">
<td><code>cost_map</code></td>
<td>flMap</td>
<td>A map that contains the resistance or cost in each cell/element.</td>
</tr>
<tr class="odd">
<td><code>error_message</code></td>
<td>Char Pointer</td>
<td>Stores the error messages that occur in the engine. It acts as a way to diagnose problems in the engine.</td>
</tr>
</tbody>
</table>
</div>
<div id="methodsfunctions" class="section level4">
<h4 class="hasAnchor">
<a href="#methodsfunctions" class="anchor"></a>Methods/Functions</h4>
<div id="public-functions" class="section level5">
<h5 class="hasAnchor">
<a href="#public-functions" class="anchor"></a>Public Functions</h5>
<p>These are the functions that are visible to the user.</p>
<table class="table">
<colgroup>
<col width="17%">
<col width="27%">
<col width="31%">
<col width="23%">
</colgroup>
<thead><tr class="header">
<th><strong>Function</strong></th>
<th><strong>Return Type</strong></th>
<th><strong>Input Arguments</strong></th>
<th><strong>Description</strong></th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>Engine</code></td>
<td>Instance of an <code>Engine</code>
</td>
<td>Nothing</td>
<td>Default Engine constructor.</td>
</tr>
<tr class="even">
<td><code>Engine</code></td>
<td>Instance of an <code>Engine</code>
</td>
<td>InputData Pointer, OutputData Pointer, Char Pointer</td>
<td>Engine constructor.</td>
</tr>
<tr class="odd">
<td><code>initialize</code></td>
<td>Boolean</td>
<td>Nothing</td>
<td>Prepares the engine for calculation.</td>
</tr>
<tr class="even">
<td><code>start</code></td>
<td>Void</td>
<td>Nothing</td>
<td>It runs the MPG algorithm.</td>
</tr>
</tbody>
</table>
</div>
<div id="linking-functions" class="section level5">
<h5 class="hasAnchor">
<a href="#linking-functions" class="anchor"></a>Linking Functions</h5>
<p>These functions create the links between cells and finds the least cost (direct or indirect) paths between patches.</p>
<table class="table">
<colgroup>
<col width="20%">
<col width="20%">
<col width="33%">
<col width="25%">
</colgroup>
<thead><tr class="header">
<th><strong>Function</strong></th>
<th><strong>Return Type</strong></th>
<th><strong>Input Arguments</strong></th>
<th><strong>Description</strong></th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>findPath</code></td>
<td>Void</td>
<td>LinkCell Pointer, LinkCell Pointer, Vector of Links</td>
<td>Finds the least cost path between two patches.</td>
</tr>
<tr class="even">
<td><code>connectCell</code></td>
<td>Void</td>
<td>ActiveCell Pointer, Integer, Integer, Float</td>
<td>Connects the child cell to the parent cell.</td>
</tr>
<tr class="odd">
<td><code>parseMap</code></td>
<td>Cell</td>
<td>LinkCell, Link</td>
<td>Given a starting Cell it follows the connections until it reaches a patch. The last cell in the connection is returned.</td>
</tr>
<tr class="even">
<td><code>lookForIndirectPath</code></td>
<td>Void</td>
<td>Vector of Links, Link</td>
<td>Tries to find an indirect link and updates the second argument.</td>
</tr>
</tbody>
</table>
</div>
<div id="patch-finding-functions" class="section level5">
<h5 class="hasAnchor">
<a href="#patch-finding-functions" class="anchor"></a>Patch Finding Functions</h5>
<p>The functions are responsible for finding the patches or clusters in a resistance map, given a value for a habitat.</p>
<table class="table">
<colgroup>
<col width="20%">
<col width="21%">
<col width="29%">
<col width="27%">
</colgroup>
<thead><tr class="header">
<th><strong>Function</strong></th>
<th><strong>Return Type</strong></th>
<th><strong>Input Arguments</strong></th>
<th><strong>Description</strong></th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>findPatches</code></td>
<td>Void</td>
<td>Nothing</td>
<td>Finds all the patches in the patch vector and assign patch IDs.</td>
</tr>
<tr class="even">
<td><code>getIndexFromList</code></td>
<td>Int</td>
<td>Float, Vector of Patches</td>
<td>Finds the index in the vector of patches that the given ID correspond to.</td>
</tr>
<tr class="odd">
<td><code>combinePatches</code></td>
<td>Int</td>
<td>Int, Int, Vector of Patches</td>
<td>Given two indices and the list of patches. Extract the two patches from the list and combine those two into one patch. Insert the new patch into the list and return the index value of the new patch.</td>
</tr>
</tbody>
</table>
</div>
<div id="common-functions" class="section level5">
<h5 class="hasAnchor">
<a href="#common-functions" class="anchor"></a>Common Functions</h5>
<p>Common functions are used in almost all of the functions in the engine.</p>
<table class="table">
<colgroup>
<col width="16%">
<col width="22%">
<col width="32%">
<col width="28%">
</colgroup>
<thead><tr class="header">
<th><strong>Function</strong></th>
<th><strong>Return Type</strong></th>
<th><strong>Input Arguments</strong></th>
<th><strong>Description</strong></th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>outOfBounds</code></td>
<td>Bool</td>
<td>Int, Int, Int, Int</td>
<td>Checks to see if the given row and column is still within the resistance map’s dimensions.</td>
</tr>
<tr class="even">
<td><code>cellIsEqual</code></td>
<td>Bool</td>
<td>Cell, Cell</td>
<td>Compares the two cells’ row and column if they match.</td>
</tr>
</tbody>
</table>
</div>
<div id="static-functions" class="section level5">
<h5 class="hasAnchor">
<a href="#static-functions" class="anchor"></a>Static Functions</h5>
<p>Static functions are functions that can be used without declaring an object of the class.</p>
<table class="table">
<colgroup>
<col width="18%">
<col width="21%">
<col width="36%">
<col width="23%">
</colgroup>
<thead><tr class="header">
<th><strong>Function</strong></th>
<th><strong>Return Type</strong></th>
<th><strong>Input Arguments</strong></th>
<th><strong>Description</strong></th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>emax</code></td>
<td>Float</td>
<td>Vector of Floats</td>
<td>Finds the maximum value from the vector of floating point values</td>
</tr>
<tr class="even">
<td><code>emin</code></td>
<td>Float</td>
<td>Vector of Floats</td>
<td>Finds the minimum value from the vector of floating point values</td>
</tr>
<tr class="odd">
<td><code>calcDistance</code></td>
<td>Float</td>
<td>Cell, Cell</td>
<td>Finds the Euclidean distance between two Cells</td>
</tr>
</tbody>
</table>
<hr>
</div>
</div>
</div>
<div id="how-to-use-the-engine" class="section level3">
<h3 class="hasAnchor">
<a href="#how-to-use-the-engine" class="anchor"></a>How to Use the Engine</h3>
<ol style="list-style-type: decimal">
<li>Create <code>InputData</code> and <code>OutputData</code> objects.</li>
<li>Initialize the <code>InputData</code> object’s fields. Keep in mind that the vectors in the InputData and Output data structures are all of type <code>float</code>.</li>
<li>Create an array of <code>Char</code> with the length of <code>MAX_CHAR_SIZE</code> or a larger value.</li>
<li>Create an <code>Engine</code> object and give the address of the <code>InputData</code> and <code>OutputData</code> objects, the <code>Char</code> array and the size of the array as arguments.</li>
<li>Call the initialization function from the <code>Engine</code> object.</li>
<li>If the initialization is successful, call the start function from the <code>Engine</code> object. If the initialization is not successful, the array of char will contain the reason for the initialization failure.</li>
<li>Once the engine is done calculating, extract all the fields needed in the <code>OutputData</code> object.</li>
</ol>
<p>A snippet C++ code is shown below as an example:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" data-line-number="1">vector&lt;<span class="dt">float</span>&gt; EngineInterface(vector&lt;<span class="dt">float</span>&gt; resistance, vector&lt;<span class="dt">float</span>&gt; patches,</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">                              <span class="dt">int</span> nrow, <span class="dt">int</span> ncol)</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">{</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    <span class="co">//InputData and OutputData objects</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">    InputData inObj;</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">    OutputData outObj; </a>
<a class="sourceLine" id="cb1-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">    <span class="co">//Initialize InputData object</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">    inObj.cost_vec = resistance;</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">    inObj.nrow = nrow;</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">    inObj.ncol = ncol;</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">    inObj.patch_vec = patches;</a>
<a class="sourceLine" id="cb1-13" data-line-number="13"></a>
<a class="sourceLine" id="cb1-14" data-line-number="14">    <span class="co">//Array of chars with a size of MAX_CHAR_SIZE</span></a>
<a class="sourceLine" id="cb1-15" data-line-number="15">    <span class="dt">char</span> error[MAX_CHAR_SIZE];</a>
<a class="sourceLine" id="cb1-16" data-line-number="16"></a>
<a class="sourceLine" id="cb1-17" data-line-number="17">    <span class="co">//Engine object while passing in the InputData and OutputData objects'</span></a>
<a class="sourceLine" id="cb1-18" data-line-number="18">    <span class="co">// address and the array of chars</span></a>
<a class="sourceLine" id="cb1-19" data-line-number="19">    Engine engineObj(&amp;inObj, &amp;outObj, error, MAX_CHAR_SIZE);</a>
<a class="sourceLine" id="cb1-20" data-line-number="20"></a>
<a class="sourceLine" id="cb1-21" data-line-number="21">    <span class="co">//Initialize the engineObj;</span></a>
<a class="sourceLine" id="cb1-22" data-line-number="22">    <span class="co">//If it fails output the reason why and exit the function</span></a>
<a class="sourceLine" id="cb1-23" data-line-number="23">    <span class="cf">if</span> (engineObj.initialize() == <span class="kw">false</span>)</a>
<a class="sourceLine" id="cb1-24" data-line-number="24">    {</a>
<a class="sourceLine" id="cb1-25" data-line-number="25">        cout &lt;&lt; error &lt;&lt; endl;</a>
<a class="sourceLine" id="cb1-26" data-line-number="26">        <span class="cf">return</span> outObj.voronoi_map;</a>
<a class="sourceLine" id="cb1-27" data-line-number="27">    }</a>
<a class="sourceLine" id="cb1-28" data-line-number="28"></a>
<a class="sourceLine" id="cb1-29" data-line-number="29">    <span class="co">//start the calculation</span></a>
<a class="sourceLine" id="cb1-30" data-line-number="30">    engineObj.start();</a>
<a class="sourceLine" id="cb1-31" data-line-number="31"></a>
<a class="sourceLine" id="cb1-32" data-line-number="32">    <span class="co">//extract the data needed, in this case the voronoi_map</span></a>
<a class="sourceLine" id="cb1-33" data-line-number="33">    <span class="cf">return</span> outObj.voronoi_map;</a>
<a class="sourceLine" id="cb1-34" data-line-number="34">}</a></code></pre></div>
<p>Note that the current Engine has two lines of code that are meant for interfacing with R. In order to make the Engine run with any programming or scripting language, remove those two lines. One of them is an <code>include</code> statement for <code>Rcpp</code>, at the very top of source code, and the other is inside the <code>start</code> function, the first line inside the <code>while</code> loop. Those two lines are convenient for R users when they want to interrupt or stop the MPG algorithm safely, without crashing their console and possibly losing their data.</p>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#overview">Overview</a></li>
      <li><a href="#technical-reference-to-the-mpg-engine-written-in-c">Technical reference to the MPG engine written in C++</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Paul Galpern, Sam Doctolero, Alex M Chubaty.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.3.0.</p>
</div>
      </footer>
</div>

  

  </body>
</html>
